---
date: "2025-07-26"
title: ""
category: ["개발"]
summary: ""
---

A페이지에서 보여지는 데이터를 엑셀로 다운받으려 할 때, 서버에서 처리시간이 길어져 사용자가 이를 기다리지 못하고 B페이지를 이탈했다고 가정해보자.  
B페이지에서 조회된 데이터를 확인하고 있는데, 요청보냈던 A페이지의 응답이 도착해서 엑셀파일을 브라우저를 통해 다운받을 수 있을까?

## 예시만들기

### Case 1

Next.js를 이용해서 간단한 예시를 만들어봤다.  
테스트는 다음과 같이 진행했다.

1. index페이지에서 'Excel 파일 다운로드 버튼 클릭'
   - 이때 응답은 최소 5초 이후에 받도록 setTimeout을 적용했다.
2. About 버튼을 클릭해서 About 페이지로 이동
   - 5초 전에 페이지를 이동시켰다.
3. 이동한 페이지에서 대기

![](./download.gif)

페이지를 이탈하더라도 response에 대한 응답이 도착하며, 다운로드가 가능한 것을 확인할 수 있다.

---

### Case 2

위 예시는 **같은 도메인이 유지**되었을 때의 경우다.  
만약, A페이지에서 B페이지로 이동할 때, B페이지가 다른 도메인이라면 어떻게 될까?

1. index페이지에서 'Excel 파일 다운로드 버튼 클릭'
2. Gmail로 도메인이 다른 페이지로 이동
3. 이동한 페이지에서 대기

![](./unknown.png)

개발자도구를 확인했을 때, `unknown`이 떠버린다.

---

### Case 3

만약 '새로고침(reload)' 시켰다면 어떻게 될까?

1. index페이지에서 'Excel 파일 다운로드 버튼 클릭'
2. 페이지 새로고침
3. 대기

![](./canceled.png)

개발자도구를 확인했을 때, `canceled`가 떠버린다.

---

## 고민하기

`Case 2`는 어찌보면 다운로드 실패하는게 당연하다.  
도메인 변경시, 브라우저가 이미 해당 요청을 취소했고, 응답을 받을 페이지가 더이상 존재하지 않는다.

`Case 3`도 새로고침으로 인해, 브라우저의 모든 실행요청을 중단시키는 것이다.

문제는 `Case 1`인데, `Case 3`에서 한 가지 힌트를 얻었다.
`Case 3`의 로직을 구현하기 위해, `window.location.reload()`함수를 사용하였다.

그럼, `window.location.href`를 사용해서 페이지를 이동할 경우에도, 다운로드는 유지될까?  
확인해보자.

![](./link-a.gif)

1. index페이지에서 'Excel 파일 다운로드 버튼 클릭'
   - 이때 응답은 최소 5초 이후에 받도록 setTimeout을 적용했다.
2. About 버튼을 클릭해서 About 페이지로 이동
   - 5초 전에 페이지를 이동시켰다.
3. 이동한 페이지에서 대기

첫 번째로 시도한 건 Link 태그를 사용한 로직이다. 위에서 확인했듯이 페이지를 이동해도 다운로드가 가능하다.

```jsx
<Link
  href="/about"
  className="flex-1 bg-green-600 hover:bg-green-700 text-white font-medium py-2 px-3 rounded text-center text-sm transition-colors duration-200"
>
  About (Link)
</Link>
```

두 번째로 시도한 a 태그를 사용한 로직이다. 영상에서 볼 수 있듯이, 페이지를 이동하면 다운로드를 실패한다.  
네트워크 탭에서 `canceled`가 뜨는 것을 확인할 수 있었다.

```jsx
<a
  href="/about"
  className="flex-1 bg-green-400 hover:bg-green-500 text-white font-medium py-2 px-3 rounded text-center text-xs transition-colors duration-200"
>
  🔗 About (a태그)
</a>
```

---

## 원인분석

### 다운로드

React는 SPA 방식으로 동작한다.  
React-Router와 같은 라우팅 라이브러리를 사용할 경우, 사용자는 URL 변경과 함께 화면도 전환되는 것처럼 보인다.

하지만, **브라우저 입장에서는 페이지 전환이 발생하지 않는다.**  
단지, 기존의 JS 런타임 컨텍스트 내에서 DOM을 조작하는 것일 뿐이다.  
즉, 페이지의 unload 이벤트가 발생하지 않기 때문에, `fetch` 또는 `Blob` 기반의 다운로드 요청도 정상적으로 유지된다.

반면, `a`태그로 다른 URL을 이동하는 경우에는 **브라우저 수준의 페이지 전환이 발생**한다.  
이 경우 브라우저는 기존 페이지를 unload하고, JS 실행 컨텍스트와 네트워크 요청을 모두 중단시킨다.  
그래서 다운로드가 중단되거나 실패할 수 있었던 것이다.

### Next.js의 SPA

위 전제는 어디까지는 SPA라는 가정에서 시작되었다.  
그럼 Next.js는 SPA가 맞나?  
`use client`가 명시된 클라이언트 컴포넌트는 CSR일까? SSR일까?

하나씩 짚어보자.

## 참고자료

[Reliably Send an HTTP Request as a User Leaves a Page](https://css-tricks.com/send-an-http-request-on-page-exit/)  
[Request: keepalive property](https://developer.mozilla.org/en-US/docs/Web/API/Request/keepalive)  
['use client'가 CSR이라고 알고 있는 거 아니죠? Next.js 면접질문 정복](https://velog.io/@k-svelte-master/nextjs-rsc-csr-ssr)
