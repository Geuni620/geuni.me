---
date: "2025-06-07"
title: "Error Boundary 컴포넌트"
category: ["개발"]
summary: "Error Boundary 컴포넌트를 직접 만들어보고, 로그를 찍어보며 어떻게 동작하는지 확인해보려고 한다."
---

import { SandpackWrapper } from "@/components/sandpack";
import {
  ERROR_BOUNDARY_NOT_SETTING_RESET_KEYS,
  ERROR_BOUNDARY_SETTING_RESET_KEYS,
} from "./file";

Error Boundary는 리액트 16버전부터 출시되었다.  
이전 회사에서 사용했던 16.14.2버전에서도 Error Boundary 컴포넌트를 사용할 수 있었으나, try-catch 문을 통해서 에러를 catch 해왔다. 명령적으로 코드를 작성했던 것이다.

선언적으로 사용했었던, 그 전 회사에서는 Error Boundary 컴포넌트를 사용했지만, [react-error-boundary](https://github.com/bvaughn/react-error-boundary)에 의존했다.

아쉽게도 이런 상황으로 인해, Error Boundary 컴포넌트를 직접 만들어보지 못했다.  
오늘은 Error Boundary 컴포넌트를 직접 만들어보고, 로그를 찍어보며 어떻게 동작하는지 확인해보려고 한다.

---

[React 공식문서](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)에서 제공하는 Error Boundary 예시는 다음과 같다.

```jsx
// ErrorBoundary.tsx
export class ErrorBoundary extends React.Component<
  React.PropsWithChildren,
  { hasError: boolean }
> {
  constructor(props: React.PropsWithChildren) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error) {
    console.log("getDerivedStateFromError", error);

    return { hasError: true };
  }

  componentDidCatch(error: Error, info: React.ErrorInfo) {
    console.log("componentDidCatch", error, info);
  }

  render() {
    if (this.state.hasError) {
      return <div>에러가 발생했어요.</div>;
    }

    return this.props.children;
  }
}

// App.tsx
function Bomb({ shouldThrow }: { shouldThrow: boolean }) {
  if (shouldThrow) {
    throw new Error("💥 특정 조건에서 발생한 에러!");
  }

  return null;
}

function RouteComponent() {
  const data = Route.useLoaderData();

  return (
    <ErrorBoundary>
      <div className="flex flex-col items-center justify-center h-full">
        <Bomb />
        <DataTable data={data.data} columns={columns} />
      </div>
    </ErrorBoundary>
  );
}
```

만약 다음과 같은 코드가 있다고 가정했을 때, Error Boundary 컴포넌트의 생명주기는 어떻게 동작할까?

[React 구버전 Docs에서 Error Boundary를 소개해준다](https://ko.legacy.reactjs.org/docs/error-boundaries.html#introducing-error-boundaries)

1. getDerivedStateFromError가 에러가 발생했음을 인지하고, 다음 렌더링에서 폴백 UI가 보이도록 상태를 업데이트한다. (hasError state를 true로 변경)
2. componentDidCatch가 호출되고, 에러와 에러 정보를 출력한다.
3. render 메서드가 호출되고, 폴백 UI가 보이도록 렌더링한다.

<br />

이대로는 조금 아쉬우니, 위 코드를 기반으로 필요한 요소들을 하나씩 추가해보자.

## renderFallback 메서드

현재는 render 메서드에서 폴백 UI를 커스텀 할 수 없다.  
이를 해결하기 위해 인터페이스(props)를 추가해보자.

```jsx
function RouteComponent() {
  const data = Route.useLoaderData();

  return (
    // 아래와 같이 renderFallback 메서드를 넣어주고 싶은 것이다.
    <ErrorBoundary renderFallback={() => <div>에러가 발생했어요.</div>}>
      <div className="flex flex-col items-center justify-center h-full">
        <Bomb shouldThrow={true} />
        <DataTable data={data.data} columns={columns} />
      </div>
    </ErrorBoundary>
  );
}
```

```jsx
import * as React from "react";

interface RenderFallbackProps {
  error: Error;
}

type Props = {
  renderFallback: (props: RenderFallbackProps) => React.ReactNode,
};

interface State {
  error: Error | null;
}

const initialState: State = {
  error: null,
};

export class ErrorBoundary extends React.Component<
  React.PropsWithChildren<Props>,
  State
> {
  state = initialState;

  static getDerivedStateFromError(error: Error) {
    console.log("getDerivedStateFromError", error);
    return { error };
  }

  componentDidCatch(error: Error, info: React.ErrorInfo) {
    console.log("componentDidCatch", error, info);
  }

  render() {
    if (this.state.error !== null) {
      return this.props.renderFallback(this.state.error);
    }

    return this.props.children;
  }
}
```

이렇게 넣고보니, renderFallback 메서드를 통해 폴백 UI가 렌더링 될텐데, 여기에 버튼을 추가해서 에러 이후의 동작을 제어할 수 있도록 하고 싶다.  
이럴 땐, resetErrorBoundary 메서드를 통해 에러를 초기화 할 수 있다.

```jsx
// ErrorBoundary.tsx
interface RenderFallbackProps {
  error: Error;
  reset: () => void;
}

//...

export class ErrorBoundary extends React.Component<
  React.PropsWithChildren<Props>,
  State
> {
  //...

  // 에러를 초기화 할 수 있는 메서드를 추가해주었다.
  resetErrorBoundary() {
    this.setState(initialState);
  }

  render() {
    if (this.state.error !== null) {
      return this.props.renderFallback({
        error: this.state.error,
        reset: this.resetErrorBoundary,
      });
    }

    return this.props.children;
  }
}

// App.tsx
function RouteComponent() {
  const data = Route.useLoaderData();

  return (
    <ErrorBoundary
      // renderFallback 메서드에 reset을 추가해주었다.
      renderFallback={({ error, reset }) => (
        <div>
          <p>{error.message}</p>
          <button onClick={reset}>초기화</button>
        </div>
      )}
    >
      <div className="flex flex-col items-center justify-center h-full">
        <Bomb shouldThrow={true} />
        <DataTable data={data.data} columns={columns} />
      </div>
    </ErrorBoundary>
  );
}
```

<br />

여기까지 만든 상태에서 본격적으로 이 글에서 제시하고 싶었던 내용을 적어보려고 한다.

[reset을 선언적으로 호출할 수 있는 인터페이스](https://jbee.io/articles/react/React%EC%97%90%EC%84%9C%20%EC%84%A0%EC%96%B8%EC%A0%81%EC%9C%BC%EB%A1%9C%20%EB%B9%84%EB%8F%99%EA%B8%B0%20%EB%8B%A4%EB%A3%A8%EA%B8%B0#reset%EC%9D%84-%EC%84%A0%EC%96%B8%EC%A0%81%EC%9C%BC%EB%A1%9C-%ED%98%B8%EC%B6%9C%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4)

여기서 제시하는 resetKey는 어떤 경우에 필요한걸까? 예시를 만들어보자.

<SandpackWrapper
  files={ERROR_BOUNDARY_NOT_SETTING_RESET_KEYS.files}
  options={{
    editorHeight: 600,
  }}
/>

User 1과 User 2를 클릭하면 에러가 발생하지 않고, 정상적으로 동작한다.  
하지만, Error User를 클릭하면 에러가 발생하고 Error Boundary 컴포넌트에서 폴백 UI가 렌더링된다.

이후 다시 User 1과 User 2를 클릭하면 에러 폴백 UI가 사라질 것이라 예상하지만 그렇게 동작하지 않는다.  
에러 폴백 UI를 사라지게 만들고 싶다면, User 1, User 2를 클릭한 상태에서, 수동으로 "리셋하기" 버튼을 클릭해야한다.

User 1과 User 2를 클릭했을 때, 에러 폴백 UI가 사라지도록 만들 순 없을까? 이를 위해 resetKeys가 추가된 것이다.

<br />

일단 왜 resetKeys를 추가해야 폴백 UI가 사라지는걸까?  
이 이유는 Error Boundary 컴포넌트 내에서 에러가 발생했을 때, 에러에 관련된 state를 관리하고 있기 때문이다.  
즉 Error가 발생하면 Error Boundary에서 catch 한 뒤, state에 에러에 대한 정보를 넣어놓는다.

이후에 User 1이나 User 2를 클릭하면, 이 Error state가 초기화 되지 않고 그대로 남아있는 것이다.  
이를 초기화 해주기 위해, componentDidUpdate 메서드에 기존 resetKeys와 이전 prevResetKeys를 비교해서 초기화 해주는 로직을 추가해주었다.

```jsx
// ErrorBoundary.tsx
export class ErrorBoundary extends React.Component<
  React.PropsWithChildren<Props>,
  State
> {
  state = initialState;

  // ...

  componentDidUpdate(prevProps: Props) {
    console.log("componentDidUpdate", prevProps, this.props);
    if (this.state.error == null) {
      return;
    }

    if (isDifferentArray(prevProps.resetKeys, this.props.resetKeys)) {
      this.resetErrorBoundary();
    }
  }

  render() {
    if (this.state.error !== null) {
      return this.props.renderFallback({
        error: this.state.error,
        reset: this.resetErrorBoundary,
      });
    }

    return this.props.children;
  }
}
```

```jsx
// utils.ts
export const isDifferentArray = (a: unknown[], b: unknown[]) => {
  return (
    a.length !== b.length || a.some((item, index) => !Object.is(item, b[index]))
  );
};

// App.tsx
function RouteComponent() {
  const data = Route.useLoaderData();
  const [currentUserId, setCurrentUserId] = useState("user1");

  return (
    <ErrorBoundary
      // resetKeys를 추가해주었다.
      resetKeys={[currentUserId]}
      renderFallback={({ error, reset }) => (
        <div className="p-4 border-2 border-red-300 rounded bg-red-50">
          <h2 className="font-bold text-red-700">에러 발생</h2>
          <p>{error.message}</p>
          <Button variant="destructive" className="mt-2" onClick={reset}>
            수동으로 리셋
          </Button>
        </div>
      )}
    >
      <UserDataDisplay userId={currentUserId} />
      <div className="mt-4">
        <DataTable data={data.data} columns={columns} />
      </div>
    </ErrorBoundary>
  );
}
```

<br />

<SandpackWrapper
  files={ERROR_BOUNDARY_SETTING_RESET_KEYS.files}
  options={{
    editorHeight: 600,
  }}
/>
