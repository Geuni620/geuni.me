---
date: "2025-06-04"
title: "막힐 때 풀어주는 테스트코드"
category: ["개발"]
summary: "막힐 때 풀어주는 테스트코드"
---

## 테스트 환경에서 로그 출력하기

```jsx
it("컴포넌트가 렌더링 된 후 debug 출력하기", async () => {
  await render(<EmptyNotice />);

  // DOM 구조 출력
  screen.debug();
});
```

`jsdom`에 컴포넌트가 어떻게 렌더링 되는지 확인할 수 있음

![element를 출력해볼 수 있음](./screen-debug.png)

---

## 의존성 패키지 모킹하기

다음과 같은 컴포넌트가 있다.

```jsx
import { useNavigate } from "react-router-dom";

const EmptyNotice = () => {
  const navigate = useNavigate();
  const handleClickBack = () => {
    navigate("/");
  };

  return (
    <Box
      sx={{
        display: "flex",
        justifyContent: "center",
        height: 400,
        alignItems: "center",
        flexDirection: "column",
      }}
    >
      <Typography sx={{ fontSize: "50px", fontWeight: "light" }}>
        텅~
      </Typography>
      <MuiLink
        underline="hover"
        onClick={handleClickBack}
        style={{ cursor: "pointer" }}
        role="link"
      >
        홈으로 가기
      </MuiLink>
    </Box>
  );
};
```

이 컴포넌트에서 "홈으로 가기" 링크를 클릭했을 때, "/" 경로로 이동하는 테스트코드를 작성해보자.

```jsx
import { useNavigate } from "react-router-dom";

const navigateFn = useNavigate();

it('"홈으로 가기" 링크를 클릭할경우 "/"경로로 navigate 함수가 호출된다', async () => {
  const { user } = await render(<EmptyNotice />);

  await user.click(screen.getByText("홈으로 가기"));
  expect(navigateFn).toHaveBeenCalledWith("/");
});
```

위 테스트코드를 그대로 실행하면 실패한다. `useNavigate` 훅이 `Router context` 없이 동작하지 않기 때문이다.

![useNavigate 훅이 Router context 없이 동작하지 않기 때문에 실패한다.](./navigate-error.png)

---

이를 해결하기 위해 navigate 함수를 모킹해보자.

```jsx
// 실제 모듈을 모킹한 모듈로 대체하여 테스트 진행
// useNavigate 훅으로 반환받은 navigate 함수가 올바르게 호출되었는가? → 스파이 함수
const navigateFn = vi.fn();

vi.mock("react-router-dom", async () => {
  const original = await vi.importActual("react-router-dom");

  return { ...original, useNavigate: () => navigateFn };
});

it('"홈으로 가기" 링크를 클릭할경우 "/"경로로 navigate함수가 호출된다', async () => {
  const { user } = await render(<EmptyNotice />);

  await user.click(screen.getByText("홈으로 가기"));
  expect(navigateFn).toHaveBeenNthCalledWith(1, "/");
});
```

vitest의 [vi.mock](https://vitest.dev/api/vi.html#vi-mock) 함수를 사용하면, react-router-dom 패키지를 모킹 할 수 있다.

- vi.mock 함수를 사용하면, 특정 패키지를 원하는 함수로 대체할 수 있다. 이때 [vi.importActual](https://vitest.dev/api/vi.html#vi-importactual) 함수를 사용하여 실제 모듈을 가져온다.
- react-router-dom 패키지를 모킹한 뒤, useNavigate를 navigateFn 함수로 대체한다.
- navigate 함수가 설정한대로 동작하는지 확인하기 위해, spy 함수를 사용해서 테스트 코드를 작성한다.

---

## setup, teardown 함수

---

## useCustomHook 테스트 코드 작성하기

다음과 같은 훅(hooks)이 있다.  
일반적으로 모달을 열고, 닫을 때 사용하는 훅이다.

```jsx
import { useState } from "react";

const useConfirmModal = (initialValue = false) => {
  const [isModalOpened, setIsModalOpened] = useState(initialValue);

  const toggleIsModalOpened = () => {
    setIsModalOpened(!isModalOpened);
  };

  return {
    toggleIsModalOpened,
    isModalOpened,
  };
};
```

이 훅의 테스트 코드를 작성해보자.

```jsx
import { renderHook, act } from "@testing-library/react";
import useConfirmModal from "./useConfirmModal";

it("호출 시 initialValue 인자를 지정하지 않는 경우 isModalOpened 상태가 false로 설정된다.", () => {
  // result: 훅을 호출하여 얻은 결과 값을 반환 → result.current 값의 참조를 통해 최신 상태를 추적할 수 있다.
  // rerender: 훅을 원하는 인자와 함께 새로 호출하여 상태를 갱신한다.
  const { result } = renderHook(useConfirmModal);

  expect(result.current.isModalOpened).toBe(false);
});

it("호출 시 initialValue 인자를 boolean 값으로 지정하는 경우 해당 값으로 isModalOpened 상태가 설정된다.", () => {
  const { result } = renderHook(() => useConfirmModal(true));

  expect(result.current.isModalOpened).toBe(true);
});

it("훅의 toggleIsModalOpened()를 호출하면 isModalOpened 상태가 toggle된다.", () => {
  const { result } = renderHook(useConfirmModal);

  act(() => result.current.toggleIsModalOpened());

  expect(result.current.isModalOpened).toBe(true);
});
```

[`renderHook`](https://testing-library.com/docs/react-testing-library/api#renderhook)함수와, [`act`](https://testing-library.com/docs/react-testing-library/api#act)함수가 눈에 띈다. 각각 어떤 역할을 하는걸까?

<br />

`renderHook` 함수는 훅을 테스트 환경에서 렌더링 할 수 있다.

```jsx
const { result, rerender } = renderHook(useConfirmModal);
```

`renderHook`함수는 result와 rerender를 반환하는데, result의 current 값을 통해 훅의 상태를 추적할 수 있다.

```jsx
const { result } = renderHook(useConfirmModal);

console.log(result.current); // { isModalOpened: false }

expect(result.current.isModalOpened).toBe(false);
```

<br />

`act`함수는 훅의 상태를 갱신할 수 있다.  
참고로 `act`함수는 `testing-library/react`패키지에서 제공해주기도 하지만, [react 패키지](https://react.dev/reference/react/act)에서도 제공해주고 있다.

> react에서 제공해주는 act를 사용할 시, 써야할 코드가 많아질 수 있어서, testing-library에서 제공해주는 act를 사용하는 것을 권장한다.

```jsx
// default false
const { result } = renderHook(useConfirmModal);

// 훅의 상태를 갱신
// act로 감싸지 않는다면, 훅의 상태가 갱신되지 않는다.
act(() => result.current.toggleIsModalOpened());

// 훅의 상태가 갱신되었는지 확인
expect(result.current.isModalOpened).toBe(true);
```

<br />

## 참고자료

[vitest discussions #5809: Mocking imported modules correctly with Vitest and React](https://github.com/vitest-dev/vitest/discussions/5809)
