---
date: "2025-04-29"
title: "useEffect를 대체하는 방법, callbackRef로 렌더링 최적화하기"
category: ["개발"]
summary: "둘은 어덯게 다를까?"
---

useEffect 대신 callbackRef를 쓰면 어떤 점이 좋아질까?  
몇 달전 Tanstack-Table 메인테이너가 트위터에 한 영상을 추천했다.  
오랫동안 '나중에 보기'에 담아두고 잊고 살다가 우연한 기회로 꺼내보게 되었다.

[What Refs Can Do for You](https://gitnation.com/contents/what-refs-can-do-for-you)  
이 영상은 반복적인 리렌더링 문제는 state 대신 callbackRef를 사용해 해결한 과정을 보여준다.  
영상 내용을 토대로 블로그에서 적용했던 코드를 수정해보자.

### 적용하기

블로그에서 useEffect를 사용하는 두 소스코드가 있다.

- 블로그 내용의 Heading 클릭시 queryParams에 추가 (이하 HeadingLink)
- TOC 리스트 생성 및 클릭 시 해당 Heading으로 이동 (이하 TOC)

블로그를 만들면서 다음과 같은 코드를 작성했다.

```jsx
// HeaderLinkWrapper.tsx
export const HeaderLinkWrapper = ({
  children,
}: {
  children: React.ReactNode;
}) => {
  const router = useRouter();
  const contentRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handleClick = (event: MouseEvent) => {
      const target = event.target as HTMLElement;

      // 클릭된 요소가 H1-H6이고 id 속성이 있으며 contentRef 내부에 있는지 확인
      if (
        target.tagName.match(/^H[1-6]$/) &&
        target.id &&
        contentRef.current?.contains(target)
      ) {
        const hash = `#${target.id}`;
        router.push(hash);
      }
    };

    const container = contentRef.current;
    if (container) {
      container.addEventListener("click", handleClick);
    }

    return () => {
      if (container) {
        container.removeEventListener("click", handleClick);
      }
    };
  }, [router]);

  return <div ref={contentRef}>{children}</div>;
};

// TOC.tsx
export const TOC = ({ toc }: { toc: TOC[] }) => {
  const [activeId, setActiveId] = useState<string>("");

  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            setActiveId(entry.target.id);
          }
        });
      },
    );

    toc.forEach((item) => {
      const element = document.getElementById(item.id);
      if (element) {
        observer.observe(element);
      }
    });

    return () => observer.disconnect();
  }, [toc]);

  return (
    <ul className="text-sm pl-1">
      {/* ... */}
    </ul>
  );
};
```

이 예시들은 모두 callbackRef로 전환할 수 있을까? 또한 적절한 변경일까?  
결론부터 이야기하자면 나는 `HeadingLink`는 callbackRef로 변경하기 적절하다 판단했고, `TOC`는 적절하지 않다고 판단했다.

---

### useEffect 대신 callbackRef

먼저 두 소스코드 다 callbackRef로 변경할 수 있다.  
그리고 변경했을 때 의도한대로 잘 동작한다.

```jsx
// HeaderLinkWrapper.tsx
export const HeaderLinkWrapper = ({
  children,
}: {
  children: React.ReactNode;
}) => {
  const router = useRouter();

  const callbackRef = (node: HTMLDivElement) => {
    const handleClick = (event: MouseEvent) => {
      const target = event.target as HTMLElement;

      if (
        target.tagName.match(/^H[1-6]$/) &&
        target.id &&
        node.contains(target)
      ) {
        const hash = `#${target.id}`;
        router.push(hash);
      }
    };

    node.addEventListener("click", handleClick);
    return () => {
      node.removeEventListener("click", handleClick);
    };
  };

  return <div ref={callbackRef}>{children}</div>;
};

// TOC.tsx
export const TOC = ({ toc }: { toc: TOC[] }) => {
  const [activeId, setActiveId] = useState<string>("");

  const listRef = () => {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            setActiveId(entry.target.id);
          }
        });
      },
    );

    toc.forEach((item) => {
      const element = document.getElementById(item.id);

      if (element && observer) {
        observer.observe(element);
      }
    });

    return () => {
      if (observer) {
        observer.disconnect();
      }
    };
  };

  return (
    <ul ref={listRef} className="text-sm pl-1">
      {/* ... */}
    </ul>
  );
};
```

하지만 TOC 컴포넌트는 위와 같이 변경하기 보단, 원래의 상태를 유지하려고 한다.  
그 이유는 아래 글을 참고하면 이해할 수 있다.

[Ref Callbacks, React 19 and the Compiler](https://tkdodo.eu/blog/ref-callbacks-react-19-and-the-compiler#ref-callback-or-useeffect)

Tkdodo의 가장 하단에 적힌 'Ref Callback or useEffect?'를 살펴보면, 다음과 같이 적혀있다.

- node에 접근이 필요하다면 ref를 선호
- node가 필요 없는 side-effect가 있다면 ref에서 처리하지 않음

TOC는 매개변수 node를 추가하는게 불필요하다.  
document를 통해 h1 ~ h6까지의 element를 추출해서, 이를 observer
TOC는 매개변수로 **node를 사용하고 있지 않고**, document를 통해 element를 찾아야 하기 때문에 사이드이펙트에 해당한다고 판단했다.

<br />

mdx 파일의 heading 값을 읽어서 클릭했을 때, queryParams에 추가해주는 로직이다.  
브라우저의 새 창을 열어서 링크를 붙여넣으면 해당 Heading의 위치로 이동해준다.  
이는 callbackRef로 변경하기 적합한 코드라고 생각되었다.

여기서 useEffect의 사용사례와 callbackRef의 사용사례가 헷갈릴 수 있다.
아래는 callbackRef가 아닌 useEffect를 사용하는 것이 더 나은 코드이다.

<br />

먼저 useEffect는 브라우저 렌더링 이후에 state를 업데이트 시킨다.  
이는 리액트와 브라우저가 렌더링을 거쳐왔던 모든 순간들을 지난 뒤, 다시 한번 렌더링을 하게 만드는 요소이다.  
그래서 많은 사람들이 useEffect를 지양하는 이유이기도 하며 예측하기 어려운 사이드이펙트를 발생시킨다.

<br />

개선하는 도중 위 블로그를 읽게 되었다.

[Ref Callbacks, React 19 and the Compiler](https://tkdodo.eu/blog/ref-callbacks-react-19-and-the-compiler)

> The react docs clearly say that while the cached result will not be arbitrarily thrown away between renders, you should still treat useCallback as a performance optimization only, which means your code should still work if you remove it. It might not work as efficiently as before, but it also shouldn't crash.
> 리액트 문서에 따르면 캐시된 결과는 렌더링 사이에 임의로 버려지지 않지만, useCallback을 성능 최적화를 위한 도구로만 취급해야 하므로 제거해도 코드가 계속 작동해야 한다고 명시되어 있습니다. 이는 useCallback을 제거하더라도 코드가 여전히 작동해야한다는 것을 의미합니다.

즉 useCallback을 성능최적화를 위한 도구로만 사용해야한다는 점이고, 이를 제거했을 때 성능최적화와 관련되지 않은 동작을 한다면 이는 바르게 사용되지 않는 케이스라고 이야기한다.  
내가 가진 코드를 한번 개선해보자.

```jsx
"use client";

import { useRouter } from "next/navigation";

export const HeaderLinkWrapper = ({
  children,
}: {
  children: React.ReactNode;
}) => {
  const router = useRouter();

  const callbackRef = (node: HTMLDivElement) => {
    const handleClick = (event: MouseEvent) => {
      const target = event.target as HTMLElement;

      if (
        target.tagName.match(/^H[1-6]$/) &&
        target.id &&
        node.contains(target)
      ) {
        const hash = `#${target.id}`;
        router.push(hash);
      }
    };

    node.addEventListener("click", handleClick);

    return () => {
      node.removeEventListener("click", handleClick);
    };
  };

  return <div ref={callbackRef}>{children}</div>;
};
```

나는 useCallback을 사용하지 않는 방식을 택했다.
그 이유는 위 코드에서 useCallback을 감싼다고 해서, 디펜던시 의존성에 router를 넣게 되는데, callback으로 감싸나 감싸지 않으나 성능의 최적화와는 무관하다고 생각되었다.  
즉, useCallback에 의존하지 않는 구조를 만들었다.

또한, react19에서 ref의 cleanup 함수가 추가되었다.
이는 더이상 useRef가 null인지 검증할 필요가 없어진 것으로 이해된다.

<br />

다음과 같이 코드를 작성한 뒤, 두 영역을 비교해봤을 때 성능상으로 다음과 같은 이 있었다.

사실 위 코드를 봤을 때 dependency 의존성만 다를 뿐 useCallback으로 생성했을 때와 동일하게 동작할 것이라고 생각된다.  
하지만 리액트의 브라우저 렌더링 과정을 확인해보면, useEffect는 React가 렌더링 되고, 이를 브라우저에 역할을 위임한 뒤, 브라우저의 렌더링까지 완료된 상태에서 useEffect가 동작한다.  
즉 브라우저 렌더링 이후에 다시 React가 렌더링을 가져가고, 브라우저에게 다시 넘기며 이를 반복하는 구조로 렌더링이 이루어지는 것이다.

하지만 아래와 같이 코드를 변경하면, 브라우저 렌더링이 끝났을 때 화면에 업데이트된 사항을 그대로 노출시킨다.  
즉 SideEffect를 발생시키지 않는 것이다.
