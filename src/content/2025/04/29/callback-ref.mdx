---
date: "2025-04-29"
title: "useEffect를 대체하는 방법, callbackRef로 렌더링 최적화하기"
category: ["개발"]
summary: "둘은 어덯게 다를까?"
---

useEffect 대신 callbackRef를 쓰면 어떤 점이 좋아질까?  
최근 Tanstack-Table 메인테이너가 트위터에 한 영상을 추천했다.  
오랫동안 '나중에 보기'에 담아두고 잊고 살다가, 우연한 기회로 꺼내보게 되었다.

[What Refs Can Do for You](https://gitnation.com/contents/what-refs-can-do-for-you)  
이 영상은, 반복적인 리렌더링 문제를 state 대신 useRef를 사용해 해결하고, 최종적으로 callbackRef로 최적화하는 과정을 보여준다.

<br />

### 적용하기

블로그를 만들면서 다음과 같은 코드를 생산했었다.

```jsx
export const HeaderLinkWrapper = ({
  children,
}: {
  children: React.ReactNode;
}) => {
  const router = useRouter();
  const contentRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handleClick = (event: MouseEvent) => {
      const target = event.target as HTMLElement;

      // 클릭된 요소가 H1-H6이고 id 속성이 있으며 contentRef 내부에 있는지 확인
      if (
        target.tagName.match(/^H[1-6]$/) &&
        target.id &&
        contentRef.current?.contains(target)
      ) {
        const hash = `#${target.id}`;
        router.push(hash);
      }
    };

    const container = contentRef.current;
    if (container) {
      container.addEventListener("click", handleClick);
    }

    return () => {
      if (container) {
        container.removeEventListener("click", handleClick);
      }
    };
  }, [router]);

  return <div ref={contentRef}>{children}</div>;
};
```

mdx 파일의 heading 값을 읽어서 클릭했을 때, queryParams에 추가해주는 로직이다.  
브라우저의 새 창을 열어서 링크를 붙여넣으면 해당 Heading의 위치로 이동해준다.  
이는 callbackRef로 변경하기 적합한 코드라고 생각되었다.

여기서 useEffect의 사용사례와 callbackRef의 사용사례가 헷갈릴 수 있다.
아래는 callbackRef가 아닌 useEffect를 사용하는 것이 더 나은 코드이다.

```tsx
interface TOC {
  id: string;
  heading: string;
  depth: number;
}

export const TOC = ({ toc }: { toc: TOC[] }) => {
  const [activeId, setActiveId] = useState<string>("");

  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            setActiveId(entry.target.id);
          }
        });
      },
      { rootMargin: "-100px 0px -66%" }
    );

    toc.forEach((item) => {
      const element = document.getElementById(item.id);
      if (element) {
        observer.observe(element);
      }
    });

    return () => observer.disconnect();
  }, [toc]);

  return (
    <ul className="text-sm pl-1">
      {toc.map((item) => (
        <li
        //...
        >
          <Link
            href={`#${item.id}`}
            className={cn(
              "hover:text-foreground transition-colors",
              activeId === item.id && "text-foreground"
            )}
          >
            {item.heading}
          </Link>
        </li>
      ))}
    </ul>
  );
};
```

<br />

먼저 useEffect는 브라우저 렌더링 이후에 state를 업데이트 시킨다.  
이는 리액트와 브라우저가 렌더링을 거쳐왔던 모든 순간들을 지난 뒤, 다시 한번 렌더링을 하게 만드는 요소이다.  
그래서 많은 사람들이 useEffect를 지양하는 이유이기도 하며 예측하기 어려운 사이드이펙트를 발생시킨다.

<br />

개선하는 도중 위 블로그를 읽게 되었다.

[Ref Callbacks, React 19 and the Compiler](https://tkdodo.eu/blog/ref-callbacks-react-19-and-the-compiler)

> The react docs clearly say that while the cached result will not be arbitrarily thrown away between renders, you should still treat useCallback as a performance optimization only, which means your code should still work if you remove it. It might not work as efficiently as before, but it also shouldn't crash.
> 리액트 문서에 따르면 캐시된 결과는 렌더링 사이에 임의로 버려지지 않지만, useCallback을 성능 최적화를 위한 도구로만 취급해야 하므로 제거해도 코드가 계속 작동해야 한다고 명시되어 있습니다. 이는 useCallback을 제거하더라도 코드가 여전히 작동해야한다는 것을 의미합니다.

즉 useCallback을 성능최적화를 위한 도구로만 사용해야한다는 점이고, 이를 제거했을 때 성능최적화와 관련되지 않은 동작을 한다면 이는 바르게 사용되지 않는 케이스라고 이야기한다.  
내가 가진 코드를 한번 개선해보자.

```jsx
"use client";

import { useRouter } from "next/navigation";

export const HeaderLinkWrapper = ({
  children,
}: {
  children: React.ReactNode;
}) => {
  const router = useRouter();

  const callbackRef = (node: HTMLDivElement) => {
    const handleClick = (event: MouseEvent) => {
      const target = event.target as HTMLElement;

      if (
        target.tagName.match(/^H[1-6]$/) &&
        target.id &&
        node.contains(target)
      ) {
        const hash = `#${target.id}`;
        router.push(hash);
      }
    };

    node.addEventListener("click", handleClick);

    return () => {
      node.removeEventListener("click", handleClick);
    };
  };

  return <div ref={callbackRef}>{children}</div>;
};
```

나는 useCallback을 사용하지 않는 방식을 택했다.
그 이유는 위 코드에서 useCallback을 감싼다고 해서, 디펜던시 의존성에 router를 넣게 되는데, callback으로 감싸나 감싸지 않으나 성능의 최적화와는 무관하다고 생각되었다.  
즉, useCallback에 의존하지 않는 구조를 만들었다.

또한, react19에서 ref의 cleanup 함수가 추가되었다.
이는 더이상 useRef가 null인지 검증할 필요가 없어진 것으로 이해된다.

<br />

다음과 같이 코드를 작성한 뒤, 두 영역을 비교해봤을 때 성능상으로 다음과 같은 이 있었다.

사실 위 코드를 봤을 때 dependency 의존성만 다를 뿐 useCallback으로 생성했을 때와 동일하게 동작할 것이라고 생각된다.  
하지만 리액트의 브라우저 렌더링 과정을 확인해보면, useEffect는 React가 렌더링 되고, 이를 브라우저에 역할을 위임한 뒤, 브라우저의 렌더링까지 완료된 상태에서 useEffect가 동작한다.  
즉 브라우저 렌더링 이후에 다시 React가 렌더링을 가져가고, 브라우저에게 다시 넘기며 이를 반복하는 구조로 렌더링이 이루어지는 것이다.

하지만 아래와 같이 코드를 변경하면, 브라우저 렌더링이 끝났을 때 화면에 업데이트된 사항을 그대로 노출시킨다.  
즉 SideEffect를 발생시키지 않는 것이다.
